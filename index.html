<!DOCTYPE html>
<html>
  <head>
    <title>Google Dragon Game</title>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas"></canvas>
      <script>
          // Game configuration
var GAME_WIDTH = 800;
var GAME_HEIGHT = 600;
var OBSTACLE_FREQUENCY = 0.02; // Probability of generating an obstacle
var OBSTACLE_SPEED = 5;
var OBSTACLE_GAP = 200; // Gap between the two parts of an obstacle
var DRAGON_SPEED = 5;
var DRAGON_ROTATION_SPEED = 0.1;

// Game variables
var canvas = document.getElementById("gameCanvas");
var ctx = canvas.getContext("2d");
var dragon = null;
var obstacles = [];
var score = 0;
var lastObstacleTime = 0;

// Initialize the game elements
function init() {
  dragon = new Dragon(GAME_WIDTH / 2, GAME_HEIGHT / 2);
}

// Update the game state
function update() {
  // Update the dragon
  if (isMobile()) {
    dragon.handleGyroscope();
  } else {
    dragon.handleKeyboard();
  }
  dragon.update();

  // Generate new obstacles
  var currentTime = Date.now();
  if (Math.random() < OBSTACLE_FREQUENCY && currentTime - lastObstacleTime > 1000) {
    obstacles.push(new Obstacle(GAME_WIDTH, OBSTACLE_GAP));
    lastObstacleTime = currentTime;
  }

  // Update the obstacles
  for (var i = 0; i < obstacles.length; i++) {
    obstacles[i].x -= OBSTACLE_SPEED;
    if (obstacles[i].x < -obstacles[i].width) {
      obstacles.splice(i, 1);
      i--;
    }
  }

  // Check for collisions
  for (var i = 0; i < obstacles.length; i++) {
    if (dragon.collidesWith(obstacles[i])) {
      endGame();
      return;
    }
  }

  // Update the score
  score += 1;
}

// Draw the game elements
function draw() {
  // Clear the canvas
  ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

  // Draw the dragon
  dragon.draw();

  // Draw the obstacles
  for (var i = 0; i < obstacles.length; i++) {
    obstacles[i].draw();
  }

  // Draw the score
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score, 10, 30);
}

// Main game loop
function gameLoop() {
  update();
  draw();
}

// Start the game loop
init();
var gameInterval = setInterval(gameLoop, 16);

// Handle mobile events
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

window.addEventListener("deviceorientation", function(event) {
  if (isMobile()) {
    dragon.handleGyroscope(event.gamma, event.beta);
  }
});

// Handle keyboard events
window.addEventListener("keydown", function(event) {
  if (!isMobile()) {
    dragon.handleKeyboard(event.keyCode);
  }
});

// Handle end game
// Handle end game
function endGame() {
  clearInterval(gameInterval);
  if (isMobile()) {
    window.removeEventListener("deviceorientation");
  } else {
    window.removeEventListener("keydown");
  }
  if (confirm("Game over! Your score is: " + score + "\nDo you want to play again?")) {
    // Restart the game
    dragon = null;
    obstacles = [];
    score = 0;
    lastObstacleTime = 0;
    init();
    gameInterval = setInterval(gameLoop, 16);
  }
}

      </script>
  </body>
</html>
